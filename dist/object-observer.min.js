!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports):"function"==typeof define&&define.amd?define(["exports"],e):e(((t="undefined"!=typeof globalThis?globalThis:t||self)["object-observer"]=t["object-observer"]||{},t["object-observer"].js={}))}(this,(function(t){"use strict";const e="insert",o="update",n="delete",r="reverse",s="shuffle",i=Symbol.for("object-observer-meta-key-0"),h={async:1},c=t=>{if(!t||"object"!=typeof t)return null;const e={},o=[];for(const[n,r]of Object.entries(t))if("path"===n){if("string"!=typeof r||""===r)throw new Error('"path" option, if/when provided, MUST be a non-empty string');e[n]=r}else if("pathsOf"===n){if(t.path)throw new Error('"pathsOf" option MAY NOT be specified together with "path" option');if("string"!=typeof r)throw new Error('"pathsOf" option, if/when provided, MUST be a string (MAY be empty)');e[n]=t.pathsOf.split(".").filter(Boolean)}else if("pathsFrom"===n){if(t.path||t.pathsOf)throw new Error('"pathsFrom" option MAY NOT be specified together with "path"/"pathsOf" option/s');if("string"!=typeof r||""===r)throw new Error('"pathsFrom" option, if/when provided, MUST be a non-empty string');e[n]=r}else o.push(n);if(o.length)throw new Error(`'${o.join(", ")}' is/are not a valid observer option/s`);return e},a={observe:{value:function(t,e){if("function"!=typeof t)throw new Error(`observer MUST be a function, got '${t}'`);const o=this[i].observers;o.some((e=>e[0]===t))?console.warn("observer may be bound to an observable only once; will NOT rebind"):o.push([t,c(e)])}},unobserve:{value:function(){const t=this[i].observers;let e=t.length;if(e){let o=arguments.length;if(o)for(;o--;){let n=e;for(;n--;)t[n][0]===arguments[o]&&(t.splice(n,1),e--)}else t.splice(0)}}},_isProxyObject_:{value:!0}},f=(t,e)=>{const o=Object.defineProperties({},a);o[i]=e;for(const n in t)o[n]=d(t[n],n,e);return o},l=(t,e)=>{let o=t.length;const n=Object.defineProperties(new Array(o),a);n[i]=e;for(let r=0;r<o;r++)n[r]=d(t[r],r,e);return n},p=(t,e)=>(Object.defineProperties(t,a),t[i]=e,t),u=(t,e)=>{if(!t)return e;let o=e;if(t.path){const n=t.path;o=e.filter((t=>t.path.join(".")===n))}else if(t.pathsOf){const n=t.pathsOf,i=n.join(".");o=e.filter((t=>(t.path.length===n.length+1||t.path.length===n.length&&(t.type===r||t.type===s))&&t.path.join(".").startsWith(i)))}else if(t.pathsFrom){const n=t.pathsFrom;o=e.filter((t=>t.path.join(".").startsWith(n)))}return o},b=(t,e)=>{try{t(e)}catch(o){console.error(`failed to notify listener ${t} with ${e}`,o)}},y=function(){const t=this.batches;this.batches=null;for(const[e,o]of t)b(e,o)},w=(t,e)=>{let o,n,r,s,i,h=t;const c=e.length;do{for(o=h.observers,i=o.length;i--;)if([n,r]=o[i],s=u(r,e),s.length)if(h.options.async){let t;h.batches||(h.batches=[],queueMicrotask(y.bind(h)));for(const e of h.batches)if(e[0]===n){t=e;break}t||(t=[n,[]],h.batches.push(t)),Array.prototype.push.apply(t[1],s)}else b(n,s);if(h.parent){const t=new Array(c);for(let o=0;o<c;o++)t[o]={...e[o]},t[o].path=[h.ownKey,...t[o].path];e=t,h=h.parent}else h=null}while(h)},d=(t,e,o)=>t&&"object"==typeof t?Array.isArray(t)?new E({target:t,ownKey:e,parent:o}).proxy:ArrayBuffer.isView(t)?new T({target:t,ownKey:e,parent:o}).proxy:t instanceof Date||t instanceof Blob||t instanceof Error?t:new K({target:t,ownKey:e,parent:o}).proxy:t,g=function(){const t=this[i],e=t.target;let o,n,s;for(e.reverse(),o=0,n=e.length;o<n;o++)if(s=e[o],s&&"object"==typeof s){const t=s[i];t&&(t.ownKey=o)}const h=[new M(r,[],void 0,void 0,this)];return w(t,h),this},v=function(t){const e=this[i],o=e.target;let n,r,h;for(o.sort(t),n=0,r=o.length;n<r;n++)if(h=o[n],h&&"object"==typeof h){const t=h[i];t&&(t.ownKey=n)}const c=[new M(s,[],void 0,void 0,this)];return w(e,c),this},j=function(t,n,r){const s=this[i],h=s.target,c=[],a=h.length,f=h.slice(0);if(n=void 0===n?0:n<0?Math.max(a+n,0):Math.min(n,a),r=void 0===r?a:r<0?Math.max(a+r,0):Math.min(r,a),n<a&&r>n){let a;h.fill(t,n,r);for(let t,l,p=n;p<r;p++)t=h[p],h[p]=d(t,p,s),p in f?(l=f[p],l&&"object"==typeof l&&(a=l[i],a&&(l=a.detach())),c.push(new M(o,[p],h[p],l,this))):c.push(new M(e,[p],h[p],void 0,this));w(s,c)}return this},m=function(t,e,n){const r=this[i],s=r.target,h=s.length;t=t<0?Math.max(h+t,0):t,e=void 0===e?0:e<0?Math.max(h+e,0):Math.min(e,h),n=void 0===n?h:n<0?Math.max(h+n,0):Math.min(n,h);const c=Math.min(n-e,h-t);if(t<h&&t!==e&&c>0){const h=s.slice(0),a=[];s.copyWithin(t,e,n);for(let e,n,f,l=t;l<t+c;l++)e=s[l],e&&"object"==typeof e&&(e=d(e,l,r),s[l]=e),n=h[l],n&&"object"==typeof n&&(f=n[i],f&&(n=f.detach())),"object"!=typeof e&&e===n||a.push(new M(o,[l],e,n,this));w(r,a)}return this},O={pop:function(){const t=this[i],e=t.target,o=e.length-1;let r=e.pop();if(r&&"object"==typeof r){const t=r[i];t&&(r=t.detach())}const s=[new M(n,[o],void 0,r,this)];return w(t,s),r},push:function(){const t=this[i],o=t.target,n=arguments.length,r=new Array(n),s=o.length;for(let e=0;e<n;e++)r[e]=d(arguments[e],s+e,t);const h=Reflect.apply(o.push,o,r),c=[];for(let t=s,n=o.length;t<n;t++)c[t-s]=new M(e,[t],o[t],void 0,this);return w(t,c),h},shift:function(){const t=this[i],e=t.target;let o,r,s,h,c;for(o=e.shift(),o&&"object"==typeof o&&(c=o[i],c&&(o=c.detach())),r=0,s=e.length;r<s;r++)h=e[r],h&&"object"==typeof h&&(c=h[i],c&&(c.ownKey=r));const a=[new M(n,[0],void 0,o,this)];return w(t,a),o},unshift:function(){const t=this[i],o=t.target,n=arguments.length,r=new Array(n);for(let e=0;e<n;e++)r[e]=d(arguments[e],e,t);const s=Reflect.apply(o.unshift,o,r);for(let t,e=0,n=o.length;e<n;e++)if(t=o[e],t&&"object"==typeof t){const o=t[i];o&&(o.ownKey=e)}const h=r.length,c=new Array(h);for(let t=0;t<h;t++)c[t]=new M(e,[t],o[t],void 0,this);return w(t,c),s},reverse:g,sort:v,fill:j,copyWithin:m,splice:function(){const t=this[i],r=t.target,s=arguments.length,h=new Array(s),c=r.length;for(let e=0;e<s;e++)h[e]=d(arguments[e],e,t);const a=0===s?0:h[0]<0?c+h[0]:h[0],f=s<2?c-a:h[1],l=Math.max(s-2,0),p=Reflect.apply(r.splice,r,h),u=r.length;let b,y,g,v;for(let t,e=0;e<u;e++)t=r[e],t&&"object"==typeof t&&(b=t[i],b&&(b.ownKey=e));for(y=0,g=p.length;y<g;y++)v=p[y],v&&"object"==typeof v&&(b=v[i],b&&(p[y]=b.detach()));const j=[];let m;for(m=0;m<f;m++)m<l?j.push(new M(o,[a+m],r[a+m],p[m],this)):j.push(new M(n,[a+m],void 0,p[m],this));for(;m<l;m++)j.push(new M(e,[a+m],r[a+m],void 0,this));return w(t,j),p}},x={reverse:g,sort:v,fill:j,copyWithin:m,set:function(t,e){const n=this[i],r=n.target,s=t.length,h=r.slice(0);e=e||0,r.set(t,e);const c=new Array(s);for(let t=e;t<s+e;t++)c[t-e]=new M(o,[t],r[t],h[t],this);w(n,c)}};class M{constructor(t,e,o,n,r){this.type=t,this.path=e,this.value=o,this.oldValue=n,this.object=r}}class A{constructor(t,e){const{target:o,parent:n,ownKey:r}=t;n&&void 0!==r?(this.parent=n,this.ownKey=r):(this.parent=null,this.ownKey=null);const s=e(o,this);this.observers=[],this.revocable=Proxy.revocable(s,this),this.proxy=this.revocable.proxy,this.target=s,this.options=this.processOptions(t.options)}processOptions(t){if(t){if("object"!=typeof t)throw new Error(`Observable options if/when provided, MAY only be an object, got '${t}'`);const e=Object.keys(t).filter((t=>!(t in h)));if(e.length)throw new Error(`'${e.join(", ")}' is/are not a valid Observable option/s`);return Object.assign({},t)}return{}}detach(){return this.parent=null,this.target}set(t,n,r){let s=t[n];if(r!==s){const h=d(r,n,this);if(t[n]=h,s&&"object"==typeof s){const t=s[i];t&&(s=t.detach())}const c=void 0===s?[new M(e,[n],h,void 0,this.proxy)]:[new M(o,[n],h,s,this.proxy)];w(this,c)}return!0}deleteProperty(t,e){let o=t[e];if(delete t[e],o&&"object"==typeof o){const t=o[i];t&&(o=t.detach())}const r=[new M(n,[e],void 0,o,this.proxy)];return w(this,r),!0}}class K extends A{constructor(t){super(t,f)}}class E extends A{constructor(t){super(t,l)}get(t,e){return O[e]||t[e]}}class T extends A{constructor(t){super(t,p)}get(t,e){return x[e]||t[e]}}const S=Object.freeze({from:(t,e)=>{if(t&&"object"==typeof t){if(t[i])return t;if(Array.isArray(t))return new E({target:t,ownKey:null,parent:null,options:e}).proxy;if(ArrayBuffer.isView(t))return new T({target:t,ownKey:null,parent:null,options:e}).proxy;if(t instanceof Date||t instanceof Blob||t instanceof Error)throw new Error(`${t} found to be one of a on-observable types`);return new K({target:t,ownKey:null,parent:null,options:e}).proxy}throw new Error("observable MAY ONLY be created from a non-null object")},isObservable:t=>!(!t||!t[i])}),k=Symbol("callback-key"),P=Symbol("targets-key");t.ObjectObserver=class{constructor(t){this[k]=t,this[P]=new Set,Object.freeze(this)}observe(t,e){const o=S.from(t);return o.observe(this[k],e),this[P].add(o),o}unobserve(t){t.unobserve(this[k]),this[P].delete(t)}disconnect(){for(const t of this[P])t.unobserve(this[k]);this[P].clear()}},t.Observable=S,Object.defineProperty(t,"__esModule",{value:!0})}));